<?php

/**
 * @file
 * GHO Footnotes module file.
 */

/**
 * Implements hook_theme().
 */
function gho_footnotes_theme() {
  return [
    'gho_footnote_list' => [
      'variables' => [
        'id' => '',
        'footnotes' => NULL,
      ],
    ],
    'gho_footnote_list__accumulated' => [
      'base hook' => 'gho_footnote_list',
      'preprocess functions' => ['gho_footnotes_populate_footnotes'],
    ],
    'gho_footnote' => [
      'variables' => [
        'id' => '',
        'content' => '',
        'backlinks' => [],
      ],
    ],
    'gho_footnote_backlink' => [
      'variables' => [
        'target' => '',
        'index' => '',
      ],
    ],
    'gho_footnote_reference' => [
      'variables' => [
        'id' => '',
        'target' => '',
        'index' => '',
      ],
    ],
  ];
}

/**
 * Implements hook_preprocess_paragraph__text().
 */
function gho_footnotes_preprocess_paragraph__text(&$variables) {
  // If there is no paragraph is (because it's new), then we generate a
  // temporary unique id. This mostly for when the paragraph is rendered in the
  // forms.
  $id = $variables['paragraph']->id();
  if (empty($id)) {
    $id = \Drupal::service('uuid')->generate();
  }

  gho_footnotes_update_text_with_footnotes('paragraph-' . $id, $variables);
}

/**
 * Implements hook_preprocess_node__story().
 */
function gho_footnotes_preprocess_node__story(&$variables) {
  // If there is no node is (because it's new), then we generate a
  // temporary unique id. This mostly for when the node is rendered in the
  // forms.
  $id = $variables['node']->id();
  if (empty($id)) {
    $id = \Drupal::service('uuid')->generate();
  }

  gho_footnotes_update_text_with_footnotes('node-' . $id, $variables);
}

/**
 * Update a text with footnotes.
 *
 * @param string $base_id
 *   Base id for the footnotes (ex: paragraph id)
 * @param array $variables
 *   Array of variables as passed to preprocess hooks.
 */
function gho_footnotes_update_text_with_footnotes($base_id, array &$variables) {
  // This module requires a field_footnotes and a field_text to work with.
  // If there is none then skip the process entirely.
  if (!isset($variables['content']['field_footnotes'], $variables['content']['field_text'])) {
    return;
  }

  $renderer = \Drupal::service('renderer');

  // Whether to accumulate the footnotes for a display later or to build them at
  // the end of the process.
  $accumulate = $variables['view_mode'] !== 'preview';

  // We render the text to ensure all the text filters are applied (like
  // the one ensuring the HTML is correct) instead of using the raw text
  // because we will replace the references and add the footnotes that may not
  // have a markup compatible with some of the text filters (like removing some
  // classes).
  $field_text_text = '';
  if (isset($variables['content']['field_text'][0])) {
    $field_text_text = $renderer->renderPlain($variables['content']['field_text'][0]);
  }

  // We render the footnotes to ensure all the text filters are applied (like
  // the one ensuring the HTML is correct) instead of using the raw text
  // so that we can more easily update the footnotes. Notably the "footnotes"
  // text format strips the `<p>` tag which makes it easier to extract the
  // content.
  $field_footnotes_text = '';
  if (isset($variables['content']['field_footnotes'][0])) {
    $field_footnotes_text = $renderer->renderPlain($variables['content']['field_footnotes'][0]);
  }

  // Extract the footnote references from the text.
  $references = gho_footnotes_extract_references($field_text_text);

  // Generate the footnotes. This will be an empty array if there are no
  // references to the footnotes or the footnotes don't match the references.
  $footnotes = gho_footnotes_generate_footnotes($base_id, $field_footnotes_text, $references, $accumulate);

  // Update the references. We already rendered the text, so we replace the
  // field item with a simple markup type render array.
  $variables['content']['field_text'][0] = [
    '#markup' => gho_footnotes_update_text($base_id, $field_text_text, $references, $footnotes),
  ];

  // Update the footnotes field.
  if ($accumulate === FALSE && !empty($footnotes)) {
    $variables['content']['field_footnotes'][0] = gho_footnotes_build_footnotes($footnotes);
  }
  // Otherwise hide the footnotes field.
  else {
    $variables['content']['field_footnotes']['#access'] = FALSE;
  }
}

/**
 * Extract the references to footnotes from a text.
 *
 * @param string $text
 *   Text with footnote references.
 *
 * @return array
 *   Associative array with the footnote reference (ex: [1]) as keys and
 *   arrays of raw value + position of the references in the text, as values.
 */
function gho_footnotes_extract_references($text) {
  $references = [];
  if (preg_match_all('/ ?\[\d+\] ?/', $text, $matches, PREG_OFFSET_CAPTURE) !== FALSE) {
    foreach ($matches[0] as $match) {
      // Store the raw value and the position of the reference so we can easily
      // replace them.
      $references[trim($match[0])][] = [$match[0], $match[1]];
    }
  }
  return $references;
}

/**
 * Generate footnotes from a raw footnotes text.
 *
 * @param string $base_id
 *   Base id (ex: paragraph id).
 * @param string $text
 *   Footnotes HTML content where each paragraph (<p>) is a footnote.
 * @param array $references
 *   List of references to the footnotes.
 * @param bool $accumulate
 *   Whether to use an accumulator for the footnotes to delay their display.
 *
 * @return array
 *   List of footnotes keyed by their reference index (ex: [1]) and with an
 *   associative array containing the footnote id, its content and backlinks for
 *   each footnote.
 */
function gho_footnotes_generate_footnotes($base_id, $text, array $references, $accumulate = TRUE) {
  $footnotes = [];
  // Once rendered the footnotes are separated by line breaks, so we can easily
  // split them.
  foreach (preg_split("/\n+/", $text) as $index => $content) {
    $reference = '[' . ($index + 1) . ']';
    $content = trim($content);
    if (!empty($content) && !empty($references[$reference])) {
      $footnote_id = 'footnote-' . $base_id . '-' . ($index + 1);
      $footnote = [
        '#theme' => 'gho_footnote',
        '#id' => $footnote_id,
        // The content of the footnote is already rendered HTML. This ensures
        // the markup is preserved and not encoded.
        '#content' => ['#markup' => $content],
        '#backlinks' => gho_footnotes_get_backlinks($footnote_id, $references[$reference]),
        '#index' => $index + 1,
      ];
      if ($accumulate === TRUE) {
        $footnotes[$reference] = gho_footnotes_static($footnote);
      }
      else {
        $footnotes[$reference] = $footnote;
      }
    }
  }
  return $footnotes;
}

/**
 * Store a footnote or return the list of accumulated footnotes.
 *
 * @param array|null $footnote
 *   If provided, the footnote will be stored in a static cache, otherwise
 *   if null, the entire list of accumulated footnotes will be returned.
 *
 * @return array
 *   Either the footnote with its index modified or the full list of stored
 *   footnotes.
 */
function gho_footnotes_static(?array $footnote = NULL) {
  static $footnotes = [];
  if (isset($footnote['#id'])) {
    // Override the footnote index to take into account all the accumulated
    // footnotes.
    $footnote['#index'] = count($footnotes) + 1;
    $footnotes[$footnote['#id']] = $footnote;
    return $footnote;
  }
  return $footnotes;
}

/**
 * Get a render array for the footnotes.
 *
 * Note: the footnotes are empty and populated in the hook_preprocess.
 *
 * @return array
 *   Render array for the footnote list.
 */
function gho_footnotes_build_footnotes(?array $footnotes = NULL) {
  $theme = 'gho_footnote_list' . (!empty($footnotes) ? '' : '__accumulated');
  return [
    '#theme' => $theme,
    '#id' => 'footnote-list',
    '#footnotes' => $footnotes,
  ];
}

/**
 * Preprocess function for the "gho_footnote_list__accumulated" theme.
 *
 * Get the list of footnotes from the static cache.
 *
 * @param array $variables
 *   Theme variables.
 */
function gho_footnotes_populate_footnotes(array &$variables) {
  $variables['footnotes'] = gho_footnotes_static();
}

/**
 * Get the reference backlinks for the footnote.
 *
 * @param string $footnote_id
 *   Footnote id.
 * @param array $references
 *   List of references to the footnote.
 *
 * @return array
 *   List of backlinks which are arrays with a target (id of the reference in
 *   the text) and a label.
 */
function gho_footnotes_get_backlinks($footnote_id, array $references) {
  $backlinks = [];
  foreach ($references as $index => $reference) {
    $backlinks[] = [
      '#theme' => 'gho_footnote_backlink',
      '#target' => $footnote_id . '-reference-' . ($index + 1),
      '#index' => $index + 1,
    ];
  }
  return $backlinks;
}

/**
 * Update the footnote references of a text.
 *
 * @param string $base_id
 *   Base id (ex: paragraph id).
 * @param string $text
 *   HTML text to update.
 * @param array $references
 *   List of references to footnotes.
 * @param array $footnotes
 *   List of footnotes keyed by reference.
 */
function gho_footnotes_update_text($base_id, $text, array $references, array $footnotes) {
  $renderer = \Drupal::service('renderer');
  // Start updating the references from the end to be able to use the extracted
  // positions otherwise they would not be correct after updating the first one.
  foreach (array_reverse($references) as $reference => $info) {
    // Get the footnote id for the reference. If not present, we will remove the
    // reference.
    $footnote_id = isset($footnotes[$reference]) ? $footnotes[$reference]['#id'] : NULL;

    // Start from the further reference in the text but preserve the index
    // as it's needed to generate the reference id for the backlinks.
    foreach (array_reverse($info, TRUE) as $index => list($value, $position)) {
      // Remove the reference and ensure we don't have double spaces left.
      if ($footnote_id === NULL) {
        $replacement = str_replace([$reference, '  '], ['', ' '], $value);
      }
      // Or generate the reference link.
      else {
        $element = [
          '#theme' => 'gho_footnote_reference',
          '#id' => $footnote_id . '-reference-' . ($index + 1),
          '#target' => $footnote_id,
          '#index' => $footnotes[$reference]['#index'],
        ];
        // The str_replace here ensures the spaces surrounding the reference are
        // preserved. We cannot blindly trim the spaces because they may be of
        // significant value depending of the language. So this is left to the
        // editors to put appropriate spaces if necessary.
        $replacement = str_replace($reference, trim($renderer->render($element)), $value);
      }
      // Note that we don't use the mb_* functions to work with "bytes" so that
      // it's compatible with the PREG_OFFSET_CAPTURE flag used to extract the
      // references which returns the positions in the string in "bytes".
      $text = substr($text, 0, $position) . $replacement . substr($text, $position + strlen($value));
    }
  }
  return $text;
}
